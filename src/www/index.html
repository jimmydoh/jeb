<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JEB Field Service Configurator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4CAF50;
            margin-bottom: 30px;
            font-size: 2em;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        .tab {
            padding: 10px 20px;
            background: #2a2a2a;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 0 5px 5px 5px;
        }
        .tab-content.active {
            display: block;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
        }
        input, textarea, select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 3px;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button.secondary {
            background: #666;
        }
        button.secondary:hover {
            background: #555;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 3px;
        }
        .status.success {
            background: #2d5016;
            color: #90EE90;
        }
        .status.error {
            background: #501616;
            color: #ffcccb;
        }
        .file-list {
            list-style: none;
        }
        .file-item {
            padding: 8px;
            background: #1a1a1a;
            margin-bottom: 5px;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-item:hover {
            background: #333;
        }
        .log-viewer {
            background: #1a1a1a;
            padding: 10px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #444;
            border-radius: 3px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .info-card h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        .info-card .value {
            font-size: 1.5em;
            color: #e0e0e0;
        }
        .telemetry-chart-container {
            margin-top: 20px;
        }
        .telemetry-chart-container h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1em;
        }
        canvas.sparkline {
            display: block;
            width: 100%;
            height: 120px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
        }
        .telemetry-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.85em;
            margin-left: 10px;
            vertical-align: middle;
        }
        .telemetry-status.connected { background: #2d5016; color: #90EE90; }
        .telemetry-status.disconnected { background: #501616; color: #ffcccb; }
        .sat-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.85em;
            margin: 3px;
        }
        .sat-badge.online { background: #2d5016; color: #90EE90; }
        .sat-badge.offline { background: #501616; color: #ffcccb; }
        /* Pixel Art Studio */
        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 1px;
            width: 320px;
            height: 320px;
            background: #111;
            border: 2px solid #444;
            border-radius: 3px;
            cursor: crosshair;
            user-select: none;
        }
        .pixel-cell {
            background: #000;
            border: none;
        }
        .palette-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
            max-width: 400px;
        }
        .palette-swatch {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            box-sizing: border-box;
        }
        .palette-swatch.selected {
            border-color: #fff;
        }
        .pixel-studio-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        .pixel-studio-controls {
            flex: 1;
            min-width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß JEB Field Service Configurator</h1>

        <div class="tabs">
            <button class="tab active" onclick="showTab('system')">System Status</button>
            <button class="tab" onclick="showTab('config')">Configuration</button>
            <button class="tab" onclick="showTab('modes')">Mode Settings</button>
            <button class="tab" onclick="showTab('files')">File Browser</button>
            <button class="tab" onclick="showTab('logs')">Logs</button>
            <button class="tab" onclick="showTab('console')">Console</button>
            <button class="tab" onclick="showTab('actions')">Actions</button>
            <button class="tab" onclick="showTab('telemetry')">Telemetry</button>
            <button class="tab" onclick="showTab('pixelart')">Pixel Art Studio</button>
        </div>

        <div id="system" class="tab-content active">
            <h2>System Status</h2>
            <div class="info-grid" id="systemStatus"></div>
            <button onclick="loadSystemStatus()">Refresh Status</button>
        </div>

        <div id="config" class="tab-content">
            <h2>Global Configuration</h2>
            <form id="configForm">
                <div class="form-group">
                    <label>WiFi SSID:</label>
                    <input type="text" name="wifi_ssid" id="wifi_ssid">
                </div>
                <div class="form-group">
                    <label>WiFi Password:</label>
                    <input type="password" name="wifi_password" id="wifi_password">
                </div>
                <div class="form-group">
                    <label>Update URL:</label>
                    <input type="text" name="update_url" id="update_url">
                </div>
                <div class="form-group">
                    <label>Debug Mode:</label>
                    <select name="debug_mode" id="debug_mode">
                        <option value="false">Disabled</option>
                        <option value="true">Enabled</option>
                    </select>
                </div>
                <button type="button" onclick="loadConfig()">Load Current Config</button>
                <button type="button" onclick="saveConfig()">Save Configuration</button>
            </form>
            <div id="configStatus" class="status" style="display:none;"></div>
        </div>

        <div id="modes" class="tab-content">
            <h2>Mode Settings</h2>
            <p style="color: #b0b0b0; margin-bottom: 15px;">Configure settings for each game mode</p>
            <div id="modesList"></div>
            <button onclick="loadModeSettings()">Refresh Mode Settings</button>
            <div id="modesStatus" class="status" style="display:none;"></div>
        </div>

        <div id="files" class="tab-content">
            <h2>File Browser</h2>
            <div>
                <label>Current Path: <span id="currentPath">/sd</span></label>
                <button onclick="loadFiles()">Refresh</button>
            </div>
            <div class="form-group" style="margin-top: 15px;">
                <label>Upload File:</label>
                <input type="file" id="fileUpload">
                <button onclick="uploadFile()">Upload to Current Directory</button>
            </div>
            <ul class="file-list" id="fileList"></ul>
        </div>

        <div id="logs" class="tab-content">
            <h2>System Logs</h2>
            <div style="display:flex; gap:10px; margin-bottom:10px; flex-wrap:wrap; align-items:center;">
                <select id="logLevelFilter" onchange="loadLogs()" style="width:auto;">
                    <option value="">All Levels</option>
                    <option value="0">DEBUG+</option>
                    <option value="1">INFO+</option>
                    <option value="2">NOTE+</option>
                    <option value="3">WARNING+</option>
                    <option value="4">CRITICAL+</option>
                    <option value="5">ERROR only</option>
                </select>
                <input type="text" id="logSearch" placeholder="Search logs‚Ä¶" oninput="loadLogs()" style="width:220px;">
                <button onclick="loadLogs()">Refresh</button>
                <button class="secondary" onclick="clearLogs()">Clear</button>
            </div>
            <div class="log-viewer" id="logViewer"></div>
        </div>

        <div id="console" class="tab-content">
            <h2>Console</h2>
            <div style="display:flex; gap:10px; margin-bottom:10px; align-items:center;">
                <button onclick="loadConsole()">Refresh</button>
                <label style="display:inline; margin:0;">
                    <input type="checkbox" id="consoleAutoRefresh" onchange="toggleConsoleAutoRefresh()"> Auto-refresh
                </label>
            </div>
            <div class="log-viewer" id="consoleViewer"></div>
            <div style="display:flex; gap:8px; margin-top:10px;">
                <input type="text" id="consoleInput" placeholder="Type command and press Enter‚Ä¶" style="flex:1;"
                       onkeydown="if(event.key==='Enter') sendConsoleInput()">
                <button onclick="sendConsoleInput()">Send</button>
            </div>
            <div id="consoleStatus" class="status" style="display:none;"></div>
        </div>

        <div id="actions" class="tab-content">
            <h2>Field Service Actions</h2>
            <div class="form-group">
                <button onclick="triggerOTAUpdate()">Trigger OTA Update</button>
                <p style="color: #b0b0b0; margin-top: 5px;">Device will update on next boot</p>
            </div>
            <div class="form-group">
                <button onclick="toggleDebugMode()">Toggle Debug Mode</button>
                <p style="color: #b0b0b0; margin-top: 5px;">Enable/disable debug logging</p>
            </div>
            <div id="actionStatus" class="status" style="display:none;"></div>
        </div>

        <div id="telemetry" class="tab-content">
            <h2>
                Real-Time Telemetry
                <span id="telemetryStatus" class="telemetry-status disconnected">Disconnected</span>
            </h2>
            <div style="margin-bottom: 15px;">
                <button onclick="startTelemetry()">Connect</button>
                <button class="secondary" onclick="stopTelemetry()">Disconnect</button>
            </div>
            <h3 style="color: #b0b0b0; margin-bottom: 10px;">Power Rails (V)</h3>
            <div class="info-grid" id="telemetryVoltages"></div>
            <h3 style="color: #b0b0b0; margin: 15px 0 10px;">Satellite Links</h3>
            <div id="telemetrySatellites"><em style="color: #666;">No satellites detected</em></div>
            <div class="telemetry-chart-container">
                <h3>Bus Voltage History</h3>
                <canvas id="voltageChart" class="sparkline" width="800" height="120"></canvas>
            </div>
        </div>

        <div id="pixelart" class="tab-content">
            <h2>üé® Pixel Art Studio</h2>
            <p style="color: #b0b0b0; margin-bottom: 15px;">Draw 16√ó16 pixel art and preview it live on the LED matrix, then save as an icon.</p>
            <div class="pixel-studio-layout">
                <div>
                    <div class="pixel-grid" id="pixelGrid" onmousedown="pixelMouseDown(event)" onmousemove="pixelMouseMove(event)" onmouseup="pixelMouseUp()"></div>
                </div>
                <div class="pixel-studio-controls">
                    <div class="form-group">
                        <label>Selected Color: <span id="selectedColorName">OFF</span></label>
                        <div id="selectedColorPreview" style="width:32px;height:32px;background:#000;border:2px solid #666;border-radius:3px;margin-top:4px;"></div>
                    </div>
                    <div class="form-group">
                        <label>Palette:</label>
                        <div class="palette-grid" id="paletteGrid"></div>
                    </div>
                    <div class="form-group" style="margin-top:15px;">
                        <label>Icon Name:</label>
                        <input type="text" id="iconName" placeholder="my_icon" maxlength="32" style="width:180px;">
                    </div>
                    <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
                        <button onclick="previewPixelArt()">‚ñ∂ Preview on Matrix</button>
                        <button onclick="savePixelArt()">üíæ Save Icon</button>
                        <button class="secondary" onclick="clearCanvas()">Clear</button>
                    </div>
                    <div id="pixelArtStatus" class="status" style="display:none;margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentPath = '/sd';

        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');

            // Auto-load content for some tabs
            if (tabName === 'system') loadSystemStatus();
            if (tabName === 'files') loadFiles();
            if (tabName === 'logs') loadLogs();
            if (tabName === 'console') loadConsole();
            if (tabName === 'modes') loadModeSettings();
            if (tabName === 'telemetry') startTelemetry();
            if (tabName === 'pixelart') initPixelArtStudio();
        }

        async function loadSystemStatus() {
            try {
                const response = await fetch('/api/system/status');
                const data = await response.json();

                const html = `
                    <div class="info-card">
                        <h3>WiFi SSID</h3>
                        <div class="value">${data.wifi_ssid}</div>
                    </div>
                    <div class="info-card">
                        <h3>IP Address</h3>
                        <div class="value">${data.ip_address}</div>
                    </div>
                    <div class="info-card">
                        <h3>Debug Mode</h3>
                        <div class="value">${data.debug_mode ? 'ON' : 'OFF'}</div>
                    </div>
                    <div class="info-card">
                        <h3>Uptime</h3>
                        <div class="value">${Math.floor(data.uptime)}s</div>
                    </div>
                    <div class="info-card">
                        <h3>Free Memory</h3>
                        <div class="value">${Math.floor(data.free_memory / 1024)}KB</div>
                    </div>
                `;
                document.getElementById('systemStatus').innerHTML = html;
            } catch (error) {
                showStatus('systemStatus', 'Error loading status: ' + error, 'error');
            }
        }

        async function loadConfig() {
            try {
                const response = await fetch('/api/config/global');
                const config = await response.json();

                document.getElementById('wifi_ssid').value = config.wifi_ssid || '';
                document.getElementById('wifi_password').value = config.wifi_password || '';
                document.getElementById('update_url').value = config.update_url || '';
                document.getElementById('debug_mode').value = config.debug_mode ? 'true' : 'false';

                showStatus('configStatus', 'Configuration loaded', 'success');
            } catch (error) {
                showStatus('configStatus', 'Error loading config: ' + error, 'error');
            }
        }

        async function saveConfig() {
            try {
                const config = {
                    wifi_ssid: document.getElementById('wifi_ssid').value,
                    wifi_password: document.getElementById('wifi_password').value,
                    update_url: document.getElementById('update_url').value,
                    debug_mode: document.getElementById('debug_mode').value === 'true'
                };

                const response = await fetch('/api/config/global', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    showStatus('configStatus', 'Configuration saved successfully', 'success');
                } else {
                    showStatus('configStatus', 'Error saving configuration', 'error');
                }
            } catch (error) {
                showStatus('configStatus', 'Error: ' + error, 'error');
            }
        }

        async function loadFiles() {
            try {
                const response = await fetch(`/api/files?path=${encodeURIComponent(currentPath)}`);
                const data = await response.json();

                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                // Add parent directory link if not at root
                if (currentPath !== '/sd' && currentPath !== '/') {
                    const li = document.createElement('li');
                    li.className = 'file-item';
                    li.innerHTML = `
                        <span>üìÅ ..</span>
                        <button class="secondary" onclick="navigateUp()">Up</button>
                    `;
                    fileList.appendChild(li);
                }

                // Add files and directories
                data.items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'file-item';
                    const icon = item.is_dir ? 'üìÅ' : 'üìÑ';
                    const size = item.is_dir ? '' : ` (${formatSize(item.size)})`;

                    li.innerHTML = `
                        <span>${icon} ${item.name}${size}</span>
                        <div>
                            ${item.is_dir ?
                                `<button class="secondary" onclick="navigateTo('${item.path}')">Open</button>` :
                                `<button class="secondary" onclick="downloadFile('${item.path}')">Download</button>`
                            }
                        </div>
                    `;
                    fileList.appendChild(li);
                });

                document.getElementById('currentPath').textContent = currentPath;
            } catch (error) {
                console.error('Error loading files:', error);
            }
        }

        function navigateTo(path) {
            currentPath = path;
            loadFiles();
        }

        function navigateUp() {
            const parts = currentPath.split('/');
            parts.pop();
            currentPath = parts.join('/') || '/';
            loadFiles();
        }

        function downloadFile(path) {
            window.location.href = `/api/files/download?path=${encodeURIComponent(path)}`;
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return Math.floor(bytes / 1024) + ' KB';
            return Math.floor(bytes / (1024 * 1024)) + ' MB';
        }
        
        const LOG_LEVEL_COLORS = {
            'DBUG': '#888',
            'INFO': '#4fc3f7',
            'NOTE': '#80deea',
            'WARN': '#ffcc02',
            'CRIT': '#ffa726',
            '!ERR': '#ef5350',
            'EMUL': '#ce93d8',
        };

        async function loadLogs() {
            try {
                const level = document.getElementById('logLevelFilter').value;
                const search = document.getElementById('logSearch').value.trim();
                let url = '/api/logs';
                const params = [];
                if (level !== '') params.push('level=' + encodeURIComponent(level));
                if (search) params.push('search=' + encodeURIComponent(search));
                if (params.length) url += '?' + params.join('&');

                const response = await fetch(url);
                const logs = await response.json();

                const logViewer = document.getElementById('logViewer');
                logViewer.innerHTML = '';

                logs.forEach(entry => {
                    const line = document.createElement('div');
                    const tag = entry.level_tag || '';
                    const color = LOG_LEVEL_COLORS[tag] || '#e0e0e0';
                    // Escape HTML to prevent XSS, then colorise
                    const text = `[${entry.time}][${tag}][${entry.source}][${entry.module}] ${entry.message}`;
                    const escaped = text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/'/g,'&#39;').replace(/"/g,'&quot;');
                    line.innerHTML = `<span style="color:${color}">${escaped}</span>`;
                    logViewer.appendChild(line);
                });

                if (logs.length === 0) {
                    logViewer.textContent = 'No log entries.';
                }

                // Scroll to bottom
                logViewer.scrollTop = logViewer.scrollHeight;
            } catch (error) {
                document.getElementById('logViewer').textContent = 'Error loading logs: ' + error;
            }
        }

        async function clearLogs() {
            try {
                await fetch('/api/logs/clear', { method: 'POST' });
            } catch (_) {}
            document.getElementById('logViewer').textContent = '';
        }

        let _consoleAutoRefreshTimer = null;

        function toggleConsoleAutoRefresh() {
            const enabled = document.getElementById('consoleAutoRefresh').checked;
            if (enabled) {
                _consoleAutoRefreshTimer = setInterval(loadConsole, 2000);
            } else {
                if (_consoleAutoRefreshTimer) {
                    clearInterval(_consoleAutoRefreshTimer);
                    _consoleAutoRefreshTimer = null;
                }
            }
        }

        async function loadConsole() {
            try {
                const response = await fetch('/api/console');
                const data = await response.json();

                // Use textContent to prevent XSS attacks
                const consoleViewer = document.getElementById('consoleViewer');
                const atBottom = consoleViewer.scrollHeight - consoleViewer.scrollTop <= consoleViewer.clientHeight + 40; // 40px tolerance
                consoleViewer.textContent = data.output;
                if (atBottom) consoleViewer.scrollTop = consoleViewer.scrollHeight;
            } catch (error) {
                document.getElementById('consoleViewer').textContent = 'Error loading console: ' + error;
            }
        }

        async function sendConsoleInput() {
            const inputEl = document.getElementById('consoleInput');
            const line = inputEl.value.trim();
            if (!line) return;
            try {
                const response = await fetch('/api/console/input', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: line })
                });
                const data = await response.json();
                if (response.ok) {
                    inputEl.value = '';
                    setTimeout(loadConsole, 200);
                } else {
                    showStatus('consoleStatus', 'Error: ' + (data.error || 'Unknown'), 'error');
                }
            } catch (error) {
                showStatus('consoleStatus', 'Error: ' + error, 'error');
            }
        }
        
        async function triggerOTAUpdate() {
            if (!confirm('Trigger OTA update? Device will update on next boot.')) return;

            try {
                const response = await fetch('/api/actions/ota-update', { method: 'POST' });
                const data = await response.json();

                if (response.ok) {
                    showStatus('actionStatus', 'OTA update scheduled for next boot', 'success');
                } else {
                    showStatus('actionStatus', 'Error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('actionStatus', 'Error: ' + error, 'error');
            }
        }

        async function toggleDebugMode() {
            try {
                const response = await fetch('/api/actions/toggle-debug', { method: 'POST' });
                const data = await response.json();

                if (response.ok) {
                    showStatus('actionStatus', 'Debug mode toggled successfully', 'success');
                    loadSystemStatus();  // Refresh status
                } else {
                    showStatus('actionStatus', 'Error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('actionStatus', 'Error: ' + error, 'error');
            }
        }

        async function loadModeSettings() {
            try {
                const response = await fetch('/api/config/modes');
                const modes = await response.json();

                const modesList = document.getElementById('modesList');
                modesList.innerHTML = '';

                for (const [modeId, modeData] of Object.entries(modes)) {
                    const modeDiv = document.createElement('div');
                    modeDiv.style.marginBottom = '20px';
                    modeDiv.style.padding = '15px';
                    modeDiv.style.background = '#1a1a1a';
                    modeDiv.style.borderRadius = '5px';

                    let html = `<h3 style="color: #4CAF50; margin-bottom: 10px;">${modeId}</h3>`;

                    modeData.settings.forEach(setting => {
                        const currentValue = modeData.current[setting.key] || setting.default;
                        html += `
                            <div class="form-group">
                                <label>${setting.label}:</label>
                                <select id="${modeId}_${setting.key}">
                                    ${setting.options.map(opt =>
                                        `<option value="${opt}" ${opt === currentValue ? 'selected' : ''}>${opt}</option>`
                                    ).join('')}
                                </select>
                            </div>
                        `;
                    });

                    html += `<button onclick="saveModeSettings('${modeId}')">Save ${modeId} Settings</button>`;
                    modeDiv.innerHTML = html;
                    modesList.appendChild(modeDiv);
                }
            } catch (error) {
                showStatus('modesStatus', 'Error loading mode settings: ' + error, 'error');
            }
        }

        async function saveModeSettings(modeId) {
            try {
                // Collect all settings for this mode
                const settings = {};
                document.querySelectorAll(`[id^="${modeId}_"]`).forEach(elem => {
                    const key = elem.id.replace(`${modeId}_`, '');
                    settings[key] = elem.value;
                });

                const response = await fetch('/api/config/modes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode_id: modeId, settings: settings })
                });

                if (response.ok) {
                    showStatus('modesStatus', `${modeId} settings saved successfully`, 'success');
                } else {
                    showStatus('modesStatus', 'Error saving settings', 'error');
                }
            } catch (error) {
                showStatus('modesStatus', 'Error: ' + error, 'error');
            }
        }

        async function uploadFile() {
            const fileInput = document.getElementById('fileUpload');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first');
                return;
            }

            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const content = e.target.result;

                    const response = await fetch(
                        `/api/files/upload?path=${encodeURIComponent(currentPath)}&filename=${encodeURIComponent(file.name)}`,
                        {
                            method: 'POST',
                            body: content
                        }
                    );

                    if (response.ok) {
                        alert(`File ${file.name} uploaded successfully`);
                        loadFiles();  // Refresh file list
                    } else {
                        const data = await response.json();
                        alert('Upload failed: ' + data.error);
                    }
                };
                reader.readAsArrayBuffer(file);
            } catch (error) {
                alert('Upload error: ' + error);
            }
        }

        function showStatus(elementId, message, type) {
            const status = document.getElementById(elementId);
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }

        // --- Telemetry / Polling ---
        let _telemetryTimer = null;
        const _voltageHistory = {};
        const CHART_MAX_POINTS = 60;
        const VOLTAGE_LABELS = {
            input_20v:  'Input (20V)',
            satbus_20v: 'SatBus (20V)',
            main_5v:    'Logic (5V)',
            led_5v:     'LED (5V)',
        };

        async function fetchTelemetry() {
            try {
                const response = await fetch('/api/telemetry/status');
                if (response.ok) {
                    const data = await response.json();
                    updateTelemetryUI(data);

                    const el = document.getElementById('telemetryStatus');
                    el.textContent = 'Connected';
                    el.className = 'telemetry-status connected';
                }
            } catch (err) {
                const el = document.getElementById('telemetryStatus');
                el.textContent = 'Reconnecting‚Ä¶';
                el.className = 'telemetry-status disconnected';
            }
        }

        function startTelemetry() {
            if (_telemetryTimer) return; // Already polling
            fetchTelemetry(); // Fetch immediately
            _telemetryTimer = setInterval(fetchTelemetry, 1000); // Poll every 1 second
        }

        function stopTelemetry() {
            if (_telemetryTimer) {
                clearInterval(_telemetryTimer);
                _telemetryTimer = null;
            }
            const el = document.getElementById('telemetryStatus');
            el.textContent = 'Disconnected';
            el.className = 'telemetry-status disconnected';
        }

        function updateTelemetryUI(data) {
            // --- Voltage cards ---
            const power = data.power || {};
            const voltEl = document.getElementById('telemetryVoltages');
            let html = '';
            for (const [key, label] of Object.entries(VOLTAGE_LABELS)) {
                const v = power[key] !== undefined ? Number(power[key]).toFixed(2) : '‚Äî';
                html += `<div class="info-card"><h3>${label}</h3><div class="value">${v} V</div></div>`;
            }
            // Show any extra voltage rails not in the label map
            for (const [key, val] of Object.entries(power)) {
                if (!VOLTAGE_LABELS[key]) {
                    html += `<div class="info-card"><h3>${key}</h3><div class="value">${Number(val).toFixed(2)} V</div></div>`;
                }
            }
            voltEl.innerHTML = html;

            // --- Satellite badges ---
            const sats = data.satellites || {};
            const satEl = document.getElementById('telemetrySatellites');
            const satKeys = Object.keys(sats);
            if (satKeys.length === 0) {
                satEl.innerHTML = '<em style="color: #666;">No satellites detected</em>';
            } else {
                satEl.innerHTML = satKeys.map(sid => {
                    const online = sats[sid].active;
                    return `<span class="sat-badge ${online ? 'online' : 'offline'}">SAT ${sid}: ${online ? 'ONLINE' : 'OFFLINE'}</span>`;
                }).join('');
            }

            // --- Sparkline chart for bus voltage ---
            const busKey = power['input_20v'] !== undefined ? 'input_20v' : Object.keys(power)[0];
            if (busKey !== undefined && power[busKey] !== undefined) {
                if (!_voltageHistory[busKey]) _voltageHistory[busKey] = [];
                _voltageHistory[busKey].push(Number(power[busKey]));
                if (_voltageHistory[busKey].length > CHART_MAX_POINTS) {
                    _voltageHistory[busKey].shift();
                }
                drawSparkline('voltageChart', _voltageHistory[busKey], busKey);
            }
        }

        function drawSparkline(canvasId, values, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            if (values.length < 2) return;

            const min = Math.min(...values) - 0.5;
            const max = Math.max(...values) + 0.5;
            const range = max - min || 1;

            // Grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            [0.25, 0.5, 0.75].forEach(frac => {
                const y = Math.round(h * frac) + 0.5;
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
            });

            // Line
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            values.forEach((v, i) => {
                const x = (i / (CHART_MAX_POINTS - 1)) * w;
                const y = h - ((v - min) / range) * (h - 10) - 5;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Label
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px monospace';
            ctx.fillText(`${label}  max:${Math.max(...values).toFixed(2)}V  min:${Math.min(...values).toFixed(2)}V`, 6, 14);
        }

        // Auto-load initial data
        loadSystemStatus();

        // --- Pixel Art Studio ---
        const GRID_SIZE = 16;
        let pixelData = new Array(GRID_SIZE * GRID_SIZE).fill(0);
        let selectedColorIndex = 0;
        let selectedColorRGB = '#000000';
        let paletteColors = {};
        let pixelArtInitialized = false;
        let isDrawing = false;

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        async function initPixelArtStudio() {
            if (pixelArtInitialized) return;
            pixelArtInitialized = true;

            // Build the 16x16 grid
            const grid = document.getElementById('pixelGrid');
            grid.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'pixel-cell';
                cell.dataset.index = i;
                grid.appendChild(cell);
            }

            // Fetch palette from server
            try {
                const resp = await fetch('/api/pixel-art/palette');
                paletteColors = await resp.json();
            } catch (e) {
                // Fallback minimal palette if server unavailable.
                // Indices match the JEB palette: 0=OFF, 11=RED, 41=GREEN, 61=BLUE
                paletteColors = {'0': {name:'OFF',r:0,g:0,b:0}, '11': {name:'RED',r:255,g:0,b:0}, '41': {name:'GREEN',r:0,g:200,b:0}, '61': {name:'BLUE',r:0,g:0,b:255}};
            }

            // Build palette swatches
            const paletteGrid = document.getElementById('paletteGrid');
            paletteGrid.innerHTML = '';
            for (const [idx, color] of Object.entries(paletteColors)) {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch' + (parseInt(idx) === 0 ? ' selected' : '');
                const hex = rgbToHex(color.r, color.g, color.b);
                swatch.style.background = parseInt(idx) === 0 ? '#111' : hex;
                swatch.title = `${idx}: ${color.name}`;
                swatch.dataset.index = idx;
                swatch.onclick = () => selectColor(parseInt(idx));
                paletteGrid.appendChild(swatch);
            }
        }

        function selectColor(idx) {
            selectedColorIndex = idx;
            const color = paletteColors[String(idx)];
            if (!color) return;
            const hex = (idx === 0) ? '#000000' : rgbToHex(color.r, color.g, color.b);
            selectedColorRGB = hex;
            document.getElementById('selectedColorName').textContent = `${idx}: ${color.name}`;
            document.getElementById('selectedColorPreview').style.background = hex;
            // Update swatch borders
            document.querySelectorAll('.palette-swatch').forEach(s => {
                s.classList.toggle('selected', parseInt(s.dataset.index) === idx);
            });
        }

        function paintCell(index) {
            if (index < 0 || index >= GRID_SIZE * GRID_SIZE) return;
            pixelData[index] = selectedColorIndex;
            const cell = document.querySelector(`.pixel-cell[data-index="${index}"]`);
            if (cell) {
                const color = paletteColors[String(selectedColorIndex)];
                if (selectedColorIndex === 0 || !color) {
                    cell.style.background = '#000';
                } else {
                    cell.style.background = rgbToHex(color.r, color.g, color.b);
                }
            }
        }

        function getCellIndexFromEvent(e) {
            const target = e.target;
            if (target && target.dataset && target.dataset.index !== undefined) {
                return parseInt(target.dataset.index);
            }
            return -1;
        }

        function pixelMouseDown(e) {
            isDrawing = true;
            const idx = getCellIndexFromEvent(e);
            if (idx >= 0) paintCell(idx);
        }

        function pixelMouseMove(e) {
            if (!isDrawing) return;
            const idx = getCellIndexFromEvent(e);
            if (idx >= 0) paintCell(idx);
        }

        function pixelMouseUp() {
            isDrawing = false;
        }

        function clearCanvas() {
            pixelData.fill(0);
            document.querySelectorAll('.pixel-cell').forEach(cell => {
                cell.style.background = '#000';
            });
        }

        async function previewPixelArt() {
            try {
                const resp = await fetch('/api/pixel-art/preview', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({pixels: pixelData})
                });
                const data = await resp.json();
                if (resp.ok && data.status === 'success') {
                    showStatus('pixelArtStatus', 'Preview sent to matrix!', 'success');
                } else if (data.status === 'no_matrix') {
                    showStatus('pixelArtStatus', 'Matrix not connected to web server', 'error');
                } else {
                    showStatus('pixelArtStatus', 'Error: ' + (data.error || 'Unknown'), 'error');
                }
            } catch (e) {
                showStatus('pixelArtStatus', 'Error: ' + e, 'error');
            }
        }

        async function savePixelArt() {
            const name = document.getElementById('iconName').value.trim();
            if (!name) {
                showStatus('pixelArtStatus', 'Please enter an icon name', 'error');
                return;
            }
            try {
                const resp = await fetch('/api/pixel-art/save', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name: name, pixels: pixelData})
                });
                const data = await resp.json();
                if (resp.ok && data.status === 'success') {
                    showStatus('pixelArtStatus', `Saved to ${data.path}`, 'success');
                } else {
                    showStatus('pixelArtStatus', 'Error: ' + (data.error || 'Unknown'), 'error');
                }
            } catch (e) {
                showStatus('pixelArtStatus', 'Error: ' + e, 'error');
            }
        }
    </script>
</body>
</html>
